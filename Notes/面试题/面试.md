# 基础

```shell
# JDK和JRE的区别
JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。
JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。
具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。

# == 和 equals 的区别是什么
== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；
equals 默认情况下是引用比较，只是很多类重载了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等

# final 在 Java 中有什么作用
final 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。

# 面向对象的三个基本特征
-封装：
-基础：
-多态：

# String类的常用方法
indexOf()：返回指定字符的索引。
charAt()：返回指定索引处的字符。
replace()：字符串替换。
trim()：去除字符串两端空白。
split()：分割字符串，返回一个分割后的字符串数组。
getBytes()：返回字符串的 byte 类型数组。
length()：返回字符串长度。
toLowerCase()：将字符串转成小写字母。
toUpperCase()：将字符串转成大写字符。
substring()：截取字符串。
equals()：字符串比较。

# 如何实现数组和 List 之间的转换
数组转List：使用Arrays.asList(array) 进行转换。
List转数组：使用List自带的 toArray() 方法。

# List、set和map的区别

# HashMap 的实现原理
HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则(元素达到8个)使用红黑树

# 抽象类与接口区别
1.接口
- 接口中只能有public abstract修饰的抽象方法
- public static final修饰的变量
- default方法

2.抽象类
- 抽象类可以有构造方法，接口中不能有构造方法
- 抽象类中可以有普通成员变量，接口中没有普通成员变量
- 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的
- 抽象类中的抽象方法的访问类型可以是public，protected
- 抽象类中可以包含静态方法，接口中不能包含静态方法
- 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意

jdk1.8的修改内容（接口）
默认方法(default)：允许在接口中增加默认方法(需要方法体)，默认方法在实现类中可以不去实现它，但是如果接口中有默认方法，实现类将默认继承这个默认方法，有需要的话可以在实现类中覆盖抽象方法。使用方式：用实现类的实例来直接点出这个默认方法。而当被覆盖后，接口中的默认方法调用为：接口名.super.默认方法。

# 重写
重写是子类对父类允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
1.声明为final的方法不能被重写。
2.声明为static的方法不能被重写，但是能够被再次声明。
3.访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
4.构造方法不能被重写。

# 重载
重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
1.被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
2.被重载的方法可以改变访问修饰符；
3.无法以返回值类型或访问修饰符作为重载函数的区分标准。

# 类的实例化方法调用顺序
父类静态变量、
父类静态代码块、
子类静态变量、
子类静态代码块、
父类非静态变量（父类实例成员变量）、
父类构造函数、
子类非静态变量（子类实例成员变量）、
子类构造函数。

# IO对比总结（同步阻塞的 BIO、同步非阻塞的 NIO、异步非阻塞的 AIO）
BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 
NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 
AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。
举个例子： 
同步阻塞（BIO）：你到饭馆点餐，然后在那等着，啥都干不了，饭馆没做好，你就必须等着！ 
同步非阻塞(NIO)：你在饭馆点完餐，就去玩儿了。不过玩一会儿，就回饭馆问一声：好了没 啊！ 
异步非阻塞(AIO)：饭馆打电话说，我们知道您的位置，一会给你送过来，安心玩儿就可以了， 类似于现在的外卖。

# Java中的四种引用类型
Java的内存回收不需要程序员负责，JVM会在必要时启动Java GC完成垃圾回收。
Java以便我们控制对象的生存周期，提供给了我们四种引用方式，引用强度从强到弱分别为：强引用、软引用、弱引用、虚引用。
1.强引用（StrongReference）：默认引用形式，不管系统资源有多紧张，JVM都不会主动回收，宁愿抛出OutOfMemeryError异常。
2.软引用（SoftReference）：只有当内存不足时，JVM才会去回收该对象，其他情况不会回收。
3.弱引用（WeakReference）：当JVM触发gc时，就会回收该对象。与软引用不同的是，不管是否内存不足，弱引用都会被回收。
4.虚引用（PhantomReference）：垃圾回收器是可以在任意时候对其进行回收的，虚引用主要用来跟踪对象被垃圾回收器回收的活动.

```



# 集合

```shell
# hashMap相关面试题
https://www.bilibili.com/video/BV16Z4y1U7HN
hashMap某个数组槽位元素超过八个后转为红黑树过程：https://www.jianshu.com/p/b7dda385f83d

# 如果hashmap溢出了怎么办
https://www.jianshu.com/p/59ccb6bcc740

# ArrayList
无参构造函数默认初始化长度为 10 ,数组扩容是会将原数组中的元素重新拷贝到新数组中,长度为原来的1.5+1(代扩容价高)

# hashmap和1.8的concurrenthashmap

# ConcurrentHashMap为什么是线程安全的？

```

# 线程

```shell
# synchronized介绍
保证在同一时刻，被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。

# synchronized锁的是什么
作用于成员变量：锁住的是对象的实例，即this对象
作用于非静态方法时：锁住的是对象的实例，即this对象
作用于静态方法：锁是所在类的Class对象
作用于代码块：指定加锁对象，对给定对象加锁

# 如何实现多线程
1.继承Thread类
优点:代码简单
缺点:该类无法继承别的类
2.实现Runnable接口
优点:继承其他类.统一实现该接口的实例可以共享资源.
缺点:代码复杂.
3.实现Callable接口
Callable中的call()方法有返回值,其他和Runnable的run()方法一样.
4.线程池方式
优点:实现自动化装配,易于管理,循环利用资源.

# 线程池的线程具体在什么时候创建一个线程或者销毁一个线程


# 有ABC三个线程，怎么编程让B在C前面执行，A在B前面执行
使用 线程.join() 方法

# 线程池实例
https://www.bilibili.com/video/BV1YN411o7Lz

# ThreadLocal

# 说一下 runnable 和 callable 有什么区别
Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
Callable接口中的call()方法是有返回值的，是一个泛型和Future、FutureTask配合可以用来获取异步执行的结果。

# 线程有哪些状态
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。
创建状态：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
就绪状态：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态，在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
阻塞状态：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend,wait等方法都可以导致线程阻塞。
死亡状态：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。

# 线程池
1.newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
2.newFixedThreadPool 创建一个定长核心线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列(没有大小限制)中。由于只有核心线程并且这些核心线程不会被回收，这样它更加快速的处理相应外界的请求。
3.newScheduledThreadPool 创建一个定长核心线程数量的线程池，而非核心线程数是没有限制的，当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务。
4.newSingleThreadExecutor 线程池内部只有一个核心线程，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
补充：在项目中，线程的创建和销毁非常消耗资源，所以在多线程场景下会使用线程池，根据自己业务逻辑的需求，使用不同的线程池。

# 线程池的优点
重用线程池的线程，避免因为线程的创建和销毁锁带来的性能开销
有效控制线程池的最大并发数，避免大量的线程之间因抢占系统资源而阻塞
能够对线程进行简单的管理，并提供一下特定的操作如：可以提供定时、定期、单线程、并发数控制等功能。


# 线程池的参数（七个）
1.corePoolSize：线程池中的核心线程数。线程池初始化时默认是没有线程的，当任务来临时才开始创建线程去执行任务
2.maximumPoolSize：最大线程数，在核心线程数的基础上可能会额外增加一些非核心线程。只有当workQueue队列填满时才会创建多于核心线程数的线程。
3.keepAliveTime：非核心线程的空闲时间超过keepAliveTime就会被自动终止回收掉，当corePoolSize=maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程)
4.unit：keepAliveTime的时间单位（时/分/秒等）
5.workQueue：用于保存任务的队列，可以为无界、有界、同步移交三种队列类型之一，当池子里的工作线程数大于corePoolSize时，这时新进来的任务会被放到队列中
6.threadFactory：创建线程的工厂类，默认使用Executors.defaultThreadFactory()，也可使用guava库的ThreadFactoryBuilder来创建
7.Handler：线程池无法继续接收任务(队列已满且线程数达到maximunPoolSize)时的饱和拒绝策略，取值有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy

# 线程池有哪些状态
-RUNNING：线程池一旦被创建，就处于 RUNNING 状态，任务数为 0，能够接收新任务，对已排队的任务进行处理。
-SHUTDOWN：不接收新任务，但能处理已排队的任务。调用线程池的 shutdown() 方法，线程池由 RUNNING 转变为 SHUTDOWN 状态。
-STOP：不接收新任务，不处理已排队的任务，并且会中断正在处理的任务。调用线程池的 shutdownNow() 方法，线程池由( RUNNING 或 SHUTDOWN ) 转变为 STOP 状态。
-TIDYING：所有的任务都销毁了，workCount为0，线程池的状态在转换为tidying状态时，会执行钩子方法 terminated()。
	1.SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态，会执行 terminated() 方法。线程池中的 terminated() 方法是空实现，可以重写该方法进行相应的处理。
	2.线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池就会由 SHUTDOWN 转变为 TIDYING 状态。
	3.线程池在 STOP 状态，线程池中执行中任务为空，就会由 STOP 转变为 TIDYING 状态。
-TERMINATED：线程池彻底终止（线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED）
```

![img](https://s4.51cto.com/images/blog/202101/16/a91f1425c132ca7e0022a0fea7d8a2da.png)





# JVM

```shell
# 内存模型（以及新生代老年代）

# jdk1.8为一个进程分配堆内存的时候默认是多大

# 类加载过程（类的生命周期），解释各个阶段的意义。

# 创建一个ArrayList在JVM里面是怎样的呢？

# JVM垃圾回收机制（https://www.jianshu.com/p/23f8249886c6）
判断垃圾：引用计数法\可达性分析算法（GCROOTS:https://www.zhihu.com/question/389362829）
垃圾回收算法：标记清除法，复制算法，标记整理算法，分代收集算法
```



# mysql

```shell
# 事务的特性和隔离级别
- 事务的特性：
  1.原子性：指事务是不可分割的工作单位，事务中的操作要么都发生，要么都不发生
  2.一致性：指事务必须使数据库从一个一致性状态变换到另外一个一致性状态
  3.隔离性：指一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
  4.持久性：指一个事务一旦被提交，它对数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

- 隔离级别：
  1.读未提交read uncommitted：会发生 脏读、不可重复读、幻读
  2.已提交读read committed：解决脏读，但是不可重复读和幻读有可能发生
  3.重复读repeatable read：解决脏读和不可重复读，但是幻读有可能发生
  4.串行化serializable：避免脏读，不可重复读，幻读的发生

 - 脏读：脏读是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
 - 不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读
 - 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。

# 常见索引类型
普通索引：仅加速查询
唯一索引：加速查询 + 列值唯一（可以有null）
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
组合/联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索

# 索引的优缺点：
创建索引可以大大提高系统的性能。
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

# MVCC 多版本并发控制（https://zhuanlan.zhihu.com/p/499067876）
数据库并发场景1.读读、2.读写、3.写写
MVCC是一种用来解决读写冲突的无锁并发控制。在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。MVCC的实现原理主要是依赖每一行记录中两个隐藏字段，undo log，ReadView
- 在并发读写操作时，可以做到在读操作时不用阻塞写操作，写操作也不阻塞读操作，提高数据库并发读写能力。
- 解决脏读、幻读、不可重复读等事务隔离问题（但不能解决更新丢失问题）

# 索引是如何存储
B+树，每个节点为主键的值，叶子节点存储索引值和数据(InnoDB)
聚簇索引上叶子节点存储的是索引值和该值对应的全部数据，辅助索引存储的为索引值和主键id（拿到主键id再去文档查找对应的数据）。

# 通过索引查找数据的流程
https://www.bilibili.com/video/BV1wV411h7Fb/

# 聚簇索引 非聚簇索引
- 聚簇索引：数据和索引放在一块，索引结构的叶子节点保存了行数据。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序是一致的。聚簇索引默认是主键，如果没有设置主键，InnoDB会选择一个非空唯一索引代替，如果没有lnnoDB会在内部生成一个名为GEN_CLUST_INDEX的隐式的聚簇索引。
- 非聚簇索引：将数据和索引分开存储，表数据的存储顺序和索引顺序无关。

# left join xxx on和where 哪个更快
因为where是在最后数据都查出来的时候去进行的筛选， 而on是在连表的时候进行的过滤，两者操作的数量级别就不一样，而且如果是用where来过滤的话，应该是逐个比较，时间复杂度应该是O(n^2)，用on的话，实际上是两个B+树索引在进行合并，或许可以利用B+树性质直接降低复杂度至O(logn)。

# 左右连接的区别
内连接（inner join）：是左表的所有行交上右表的所有行得出的结果集（取交集）
左连接（left join）：是左表的所有行匹配上右表得出的结果集
右连接（right join）：是右表的所有行匹配上左表得出的结果集
全连接（full join）：是左表的所有行并上右表的所有行得出的结果集（取并集）

# mysql锁机制
数据库锁机制简单来说，就是数据库为了保证数据的一致性，使各种共享资源在被访问时变得有序而设计的一种规则!
1.根据锁的粒度可分为表级锁 行级锁 页级锁（https://m.php.cn/article/418290.html）
-行锁：锁一行数据，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
-表锁：锁整个表，开销小，加锁快；不会出现死锁；锁的粒度大，发生锁冲突的概率最高，并发度最低。
-页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
2.从锁得操作上可以分为读锁和写锁（https://blog.csdn.net/sinat_41815248/article/details/94591340）
-读锁（共享锁/S锁）：若事务T对数据A加了读锁，则T可以读A，不能写A，其它事务只能读A不能写A
-写锁（排它锁/独占锁/X锁）：若事务T对数据A加了写锁，则事务T可以对其读和写；其它事务对其读和写操作会被堵塞，直到事务T释放了锁。
3.从实现方式上分为乐观锁和悲观锁（https://xue.baidu.com/okam/pages/strategy-tp/index?strategyId=133252852148946）
-乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
-悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。


互斥锁、自旋锁、读写锁、悲观锁、乐观锁：https://baijiahao.baidu.com/s?id=1678252166115910894

# 数据库横表转纵表、纵表转横表怎么做


# union和union all的区别
union：对两个结果集进行并集操作，去重，同时进行默认规则的排序；
union All：对两个结果集进行并集操作，不去重，不进行排序；

# 分表分库的原则

```

# redis

```shell
# 过期删除策略（3种）
- 定时删除
  当我们设置一个key到redis时，用一个定时器来负责监视key，当这个key过期就自动删除。虽然内存及时释放，但是十分消耗CPU资源
- 定期删除
  redis默认每隔100ms就会随机抽取一些设置了过期时间的key,检查其是否过期，过期就删除。
- 惰性删除
  当我们获取某个key的时候，再临时检查该key是否过期，过期则删除。惰性删除的缺点也很明显，就是如果一些key使用频率低，那么它可能   长时间存在内存中，占用大量内存

redis使用的过期删除策略是：惰性删除+定期删除。使用这两种结合能很大程度上提高优化redis性能，降低冗余。但还是会有问题，假如定期删除刚好没有删除掉某些过期key,而且这些key又没有使用，这时候就不会触发惰性删除，这些key将长时间存在内存中，占用大量内存，这时候就需要使用内存淘汰机制处理掉这些key.

# 内存数据淘汰机制（6种淘汰策略）
noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

# 缓存击穿
如果缓存中的某些热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。（我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。）

解决方法：
- 互斥锁方案：保证同一时间只有一个线程更新缓存，未能获取互斥锁的请求要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
- 热点数据不设置过期时间

# 缓存穿透
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，应该去后端系统查询（比如数据库）。如果key对应的value不存在，并且对key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

解决方法：
- 非法请求校验：在接口层增加判断请求参数书是否合理，不合理直接返回错误，避免进一步访问缓存和数据库。
- 缓存空值或默认值：查询不到的数据也存入redis，存为空或者默认值，设置较短的过期时间。
- 使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回。
布隆过滤器：https://baijiahao.baidu.com/s?id=1711662604558494579


# 缓存雪崩
当redis服务器 重启 或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如数据库）带来很大的压力。缓存雪崩是指在我们设置缓存时设置了相同的过期时间，导致缓存在某一时期同时失效，请求全部转发到DB，DB瞬间压力过大雪崩。

解决方法：
- 缓存过期时间设置随机：给缓存数据设置过期时间时，避免将大量的数据设置成同一个过期时间。可以在设置过期时间时，加上一个随机数，这样就保证数据不会在同一时间过期。
- 加互斥锁：保证同一时间只有一个线程更新缓存，当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

- 构建集群(故障前)：通过主从节点的方式构建Redis集群。如果主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务。
- 服务熔断(故障时)：可以启动服务熔断机制，暂停对redis服务的访问，直接返回错误，不再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行。等到Redis恢复正常后，再允许访问redis服务。服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服务系统，全部业务都无法正常工作。
- 请求限流(故障时)：为了减少对业务的影响，我们可以启用请求限流机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

# 持久化
把内存中的数据写入到磁盘中去，防止服务宕机导致内存数据丢失。
-RDB（redis database）
Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。
-触发机制
手动触发（save）：阻塞主进程，待持久化操作完成后，恢复正常运行。（bgsave）：创建子进程（fork），后台执行持久化操作。
自动触发：redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；
         主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；
         执行debug reload命令重新加载redis时也会触发bgsave操作；
         默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；

-AOF（append Only File）
每有新增修改操作的时候就会将命令写入到缓存区中，按照配置的规则进行刷新缓存区到磁盘。当aof文件过大时会进行文件重写
-触发机制
everysec：每秒刷一次
always：每有更新操作就刷一次
no：由操作系统自己决定什么时候刷新


# redis部署方式
单机版
主从复制：主 负责写入，从 负责读取
哨兵模式：哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。
集群：采用集群，就是分布式存储。每台redis存储不同的内容

# 缓存更新策略（https://blog.csdn.net/fly910905/article/details/122553972）
- 先删缓存，再更新数据库（不推荐）
- 旁路缓存(Cache Aside) 先更新数据库，再删缓存（常用）
- 先更新数据库，再更新缓存
- 读/写直通(Read/Write Through)：缓存未命中时由缓存加载数据库数据然后应用从缓存读，写数据时更新完缓存后同步写数据库。
- 写回(Write Back)：在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库

# 五种数据类型底层实现


# redis为什么这么快
核心是基于非阻塞的IO多路复用机制,由监听程序轮询等待的事件,然后压入队列,可以达到一个线程同时处理多个io请求的目的
纯内存操作
单线程避免了多线程的频繁切换问题

# 为什么不用Redis做数据存储，而选择用Mysql


```

# mq

消息中间件的通信方式有几种（点对点和发布订阅）

```shell
http://www.bjpowernode.com/hot/1967.html
# 消息队列有什么优缺点?
优点：解耦、异步、削峰
缺点：
系统可用性降低：消息队列挂了的话，系统会出问题。因此，系统可用性会降低，系统引入的外部依赖越多，越容易挂掉。
系统复杂度提高：加入了消息队列，要多考虑很多问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。
一致性问题

A 系统处理完了直接返回成功了，人都以为你这个请求就成功了;但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这数据就不一致了。
```

# es

```shell
# 倒排索引和正向索引
查看笔记 es.md 文件
```



# 设计模式

```shell
# 单例模式
饿汉模式：一开始类加载的时候就已经实例化，并且创建单例对象，以后只管用即可。
懒汉模式：一开始不会实例化，什么时候用就什么时候new，才进行实例化。（线程安全）

# 工厂模式

# 代理模式

```



# 数据结构

**链表**

**树**

**1. 二叉树**

```shell

```

**2. 二叉查找树-BST**

```shell

```

**3. 平衡二叉树-AVL**

```shell

```

**4.红黑树**

```shell
# 红黑树的特性
1.节点是红色或黑色。
2.根节点是黑色。
3.每个叶子节点都是黑色的空节点（NIL节点）。
4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
```

5.哈夫曼树

```shell

```

6.B树

```shell
B树和B+树的区别：https://www.cnblogs.com/George1994/p/7008732.html
```

7.B+树

```shell
# 数据库索引为什么使用B+树
数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。
正是为了解决这个问题，B+树应运而生。
B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

```

8.R树

```shell

```



你了解哪些二叉树的种类和他们的具体使用场景

B+树相比于哈希索引有什么优点？

# 框架

**spring**

```shell
# AOP
SpringAOP是对面向对象编程的一种补充,用于处理系统中分布的各个模块的横切关注点,比如事务管理、日志、缓存等.它是使用动态代理实现的,在内存中临时为增强某个方法生成一个AOP对象,这个对象包含目标对象的所有方法,在特定的切入点做了增强处理,并回调原来的方法.

# aop实现方式
Spring AOP的动态代理主要有两种方式实现,JDK动态代理和cglib动态代理.JDK动态代理通过反射来接受被代理的类,但是被代理的类必须实现接口,核心是InvacationHandler和Proxy类.cglib动态代理的类一般是没有实现接口的类,cglib是一个代码生成的类库,可以在运行时动态生成某个类的子类.所以,cglib是通过继承的方式做的动态代理,因此如果某个类被标记为final,那么它是无法使用cglib做动态代理的.

# AOP实际使用过程
https://www.jianshu.com/p/a82509c4bb0d

# Spring bean的生命周期
https://wenku.baidu.com/view/af7cc413edfdc8d376eeaeaad1f34693daef102e.html
1.Spring启动，查找并加载需要被Spring管理的bean，进⾏Bean的实例化。实例化Bean对象是通过反射的⽅式来⽣成，在源码
AbstractAutowireCapableBeanFactory类中中有⼀个createBeanInstance()⽅法是专门来⽣成对象的
2.Bean实例化后将Bean的值注⼊到Bean的属性中。当bean对象创建完成之后，对象的属性值都是默认值，所以要开始给bean填充属性，
通过AbstractAutowireCapableBeanFactory类中的populateBean()⽅法来完成对象属性的填充，中间会涉及到循环依赖的问
题，Spring通过三级缓存解决了这个问题。
3.如果Bean实现了BeanNameAware接⼝的话，Spring将Bean的Id传递给setBeanName()⽅法
4.如果Bean实现了BeanFactoryAware接⼝的话，Spring将调⽤setBeanFactory()⽅法，将BeanFactory容器实例传⼊
5.如果Bean实现了ApplicationContextAware接⼝的话，Spring将调⽤Bean的setApplicationContext()⽅法，将bean所在应⽤上下⽂
引⽤传⼊进来。
6.如果Bean实现了BeanPostProcessor接⼝，Spring就将调⽤他们的postProcessBeforeInitialization()⽅法。
7.如果Bean 实现了InitializingBean接⼝，Spring将调⽤他们的afterPropertiesSet()⽅法。类似的，如果bean使⽤init-method声明了初
始化⽅法，该⽅法也会被调⽤
8.如果Bean 实现了BeanPostProcessor接⼝，Spring就将调⽤他们的postProcessAfterInitialization()⽅法。
9.此时，Bean已经准备就绪，可以被应⽤程序使⽤了。他们将⼀直驻留在应⽤上下⽂中，直到应⽤上下⽂被销毁。
10.如果bean实现了DisposableBean接⼝，Spring将调⽤它的destory()接⼝⽅法，同样，如果bean使⽤了destory-method 声明销毁⽅
法，该⽅法也会被调⽤。

#spring有几级缓存，详述
三级
1.实例化、初始化完毕
2.实例化、未初始化
3.生产对象的工厂

# beanFactory在哪里用到了

# aspectJ和springAop的区别

```

**mybatis**

````shell
# Mybatis 的 ${} #{}的区别是什么？

````

**spring mvc**

```shell
# Spring MVC中 @RequestMapping的实现原理


```



# 算法

时间复杂度 和 空间复杂度

```shell
# 回溯算法
17电话号码的字母组合、39组合总和

# 动态规划


# 贪心算法

# 链表

# 双指针
两个端点

# 滑动窗口
区间

# tree

# dfs，bfs
leetcode（104二叉树最大深度、111二叉树最小深度、112路经总和、257二叉树的所有路径、144二叉树的前序遍历、145二叉树的后序遍历）（200岛屿数量、102二叉树的层序遍历、107二叉树的层序遍历Ⅱ）

# 二分法
声明左右指针，while(l<r){int mid = l+(r-l)/2;判断大于mid、等于mid、小于mid 的情况}
34.在排序数组中查找元素的第一个和最后一个位置

# 并查集
leetcode（200岛屿数量、684冗余连接）

# 位运算
leetcode（136只出现一次的数字 结论：0^any = any  a^a=0 a^b^b^c^c=a^c^b^b^c=a）

# 矩阵翻转
48旋转图像（交换元素/水平和垂直翻转矩阵）

# 其他
进制转换
- 16进制转为10进制，每一位乘16的 当前位数减一 次幂，再各个相加
- 2进制转为10进制，每一位乘2的 当前位数减一 次幂，再各个相加即可
- 10进制转为2进制，十进制数 % 2 得到余数记为x1，把结果再拿去取余，依次进行下去，最后结果就是 xn xn-1 ...x1
```



# 其它

```shell
# 浏览器输入url按回车会发生什么
用户输入网址
进行DNS域名解析，将地址解析成ip地址
建立TCP连接（TCP三次握手）
发送http请求
接收响应
渲染页面
断开TCP连接（TCP的四次挥手）--可回答也可不回答

# 什么是死锁
当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。

# 死锁的四个必要条件
互斥条件（Mutual exclusion）：资源不能被共享，只能由一个进程使用。
请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

# 处理死锁的策略
1.忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
2.检测死锁并且恢复。
3.仔细地对资源进行动态分配，以避免死锁。
4.通过破除死锁四个必要条件之一，来防止死锁产生。

# 怎么防止死锁
尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。
尽量使用 Java. util. concurrent 并发类代替自己手写锁。
尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
尽量减少同步的代码块。

# long和float互转会发生什么

# mysql有几级缓存，都有什么作用

# java基础数据类型的取值范围（一个字节等于八个比特位）
byte：-128 ~ 127（-2的7次方到2的7次方-1）
short：-32768~32767（-2的15次方到2的15次方-1）
int：-2147483648~2147483647（-2的31次方到2的31次方-1）
long：-9223372036854774808~9223372036854774807（-2的63次方到2的63次方-1）
float：3.402823e+38~1.401298e-45（e+38表示乘以10的38次方，而e-45表示乘以10的负45次方）
double：1.797693e+308~4.9000000e-324（同上）


# http1.0和http2.0的区别

# http和https的区别

# 三次握手、四次挥手

# 项目的限流怎么实现的

# Mysql、Redis、MQ 之间的区别和适用场景？

# 两个文件，各有两个行，一个是身份证号、名字，一个是身份证号、年龄。内存不足的情况下，如果进行合并？

# 计算机网络七层协议的理解
一、主机A到主机B数据的传输过程
A主机：
1、数据的产生肯定是一个应用层的程序产生的，如IE浏览器等等。这些程序在应用层需要有不同的接口，IE是浏览网页的使用HTTP协议，那么HTTP应用层为浏览网页的软件留下的网络接口。
2、应用层处理好数据就交给运输层。
　　---首先A要知道B在哪里：使用DNS解析出B的IP地址
　　---交给运输层的数据：源端口，目的端口，原IP，目的IP，数据部分
3、运输层给数据加上首部（TCP首部/UDP首部）构成TCP/UDP报文，交给网络层（IP层）。
　　---UDP报文：无连接，没有拥塞控制，不可靠，首部开销小，支持一对一、一对多、多对一、多对多，效率快
　　---TCP报文：面向连接：TCP := {socket1,socket2}    socket = (IP地址：端口号)，三次握手，四次挥手
　　　　　　　　可靠传输：等待停止协议，连续ARQ（自动传输重传）协议，滑动窗口协议
　　　　　　　　流量控制：通过滑动窗口实现
　　　　　　　　拥塞控制：慢开始，拥塞避免，快恢复
4、网络层给报文加上IP首部构成IP数据报交给数据链路层。
　　---IP层的主要目的是转发分组：路由器，路由表
　　　　　　　　　　　　　　　　地址解析协议ARP（通过IP地址，找到对应的硬件地址）　　　　　　　　
5、数据链路层给IP数据报加上首部和尾部构成MAC帧，交给物理层。
　　---封装成帧、透明传输、差错检测
6、物理层将数据链路层的数据转换成电流传输的物理线路。

B主机
7、通过物理线路传递的B主机后，B主机会将电信号转换成数据链路层的数据MAC帧。
8、数据链路层给MAC帧报去掉首部和尾部构成IP数据报，交给IP层。
9、IP层去掉首部构成报文交给运输层。
10、运输层去掉首部，根据端口号交给应用层中对应的应用程序。

```





