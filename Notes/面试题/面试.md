# 面试：

### 1、熟练掌握 Java 基础，深入理解面向对象编程思想、具有良好的编码习惯;

```shell
# 1.1 什么是面向对象编程?
当我们接到需求时，首先就是一类具有相同属性和动作的实体抽象成类, 也就是对象的模板, 
把属性和方法封装在一个类中，处理业务的流程就是对象之间的信息传递，把程序中的所有东西当做对象来进行处理。

# 1.2 为什么需要面向对象编程?
面向对象编程更加模块化,更加易于构建大型项目. 而且面向对象编程有利于更新和维护, 其简化了企业级的编程的协同问题

# 1.3 面向对象编程相对于面向过程编程有什么优势?
项目可以做的更大,模块之间解耦, 调用更简单, 易于修改和维护, 适合大型项目

# 1.4 面向对象编程的核心思想是什么?
一切皆对象，同类型之间的对象有相同的属性和方法, 同类型的对象都可以处理相同的消息, 以对象为基础, 对象当中封装了
属性和方法, 所有的业务操作转变成对象的行为和对象之间的消息传递.

# 1.5 面向对象编程的要素有哪些?
 类: 具有相同特征的对象的模板
对象: 一切皆对象, 具有状态和行为的实体
属性: 属性对应着对象的状态, 是表示对象状态的数据结构
方法: 方法对应着对象的行为, 是对象行为的一种抽象, 是处理业务逻辑的关键所在
继承: 继承的主要目的是实现方法的多态性和代码的可重用性
多态: 指方法的重载和方法的重写, 在相同名称的方法下, 根据不同的情况调用对应的方法, 有助于实现灵活多变的实际业务需求
封装: 封装就是把属性和方法封装到一个类中, 通过方法来修改和执行业务, 有利于后期的修改和维护

# 1.6 什么是对象?
万物皆对象, 对象是具有状态和行为的一切实体, 对象可以是具体的物品,也可以是抽象的物品
```



### 2、掌握 mysql 关系型数据库与非关系型数据库 redis

```shell
#2.1 事务的特性和隔离级别**

- 事务的特性：

  1.原子性（Atomicity）
  ​	原子性指事务是不可分割的工作单位，事务中的操作要么都发生，要么都不发生

  2.一致性（Consistency）
  ​	事务必须使数据库从一个一致性状态变换到另外一个一致性状态

  3.隔离性（Isolation）
  ​	事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执   	行的各个事务之间不能互相干扰。

  4.持久性（Durability）
  ​	持久性指一个事务一旦被提交，它对数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

- 隔离级别：

  读未提交read uncommitted： 会发生 脏读、不可重复读、虚读

  已提交读read committed：解决脏读，但是不可重复读和虚读有可能发生

  重复读repeatable read：解决脏读和不可重复读，但是虚读有可能发生.

  串行化serializable：避免脏读，不可重复读，虚读的发生

  - 脏读：脏读是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
  - 不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读
  - 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。

# 2.2  InnoDB，MyISAM存储引擎特性


```



### 3、掌握 ssm 开源框架，熟练使用 springboot、mybatisPlus; 

ssm

### 4、熟悉基于 springcloud + nacos 的分布式应用开发，了解分布式架构思想; 

思想

### 5、熟悉 Redis 缓存 、rabbitMQ 消息队列; 

redis，mq

### 6、熟悉 Linux 常用命令、Docker 容器、JVM 内存结构; 

linux，jvm内存，垃圾回收

### 7、熟练使用 Idea、Maven、Git、swagger 等开发工具和技术。

swagger，git

### 8、了解 html、css 、js、jquery、vue 等前端技术;

js，vue







# 大厂必备

简介：进大厂需要准备的知识点

## jvm

内存模型（以及新生代老年代）

jdk1.8为一个进程分配堆内存的时候默认是多大
那手动为进程分配堆内存要设置哪些参数

类加载过程（类的生命周期），解释各个阶段的意义。

创建一个ArrayList在JVM里面是怎样的呢？

## mysql

索引

```shell
# 常见索引类型
普通索引：仅加速查询
唯一索引：加速查询 + 列值唯一（可以有null）
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
组合/联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索

# 索引的优缺点：
创建索引可以大大提高系统的性能。
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

# MVCC 多版本并发控制
数据库并发场景1.读读、2.读写、3.写写
MVCC是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的快照，所以MVCC可以为数据库解决如下问题：
- 在并发读写操作时，可以做到在读操作时不用阻塞写操作，写操作也不阻塞读操作，提高数据库并发读写能力。
- 解决脏读、幻读、不可重复读等事务隔离问题（但不能解决更新丢失问题）

# 索引是如何存储
B+树

# 聚簇索引 非聚簇索引
```

mysql做分页怎么做呢？

limit底层是怎么实现的呢？

mysql的优化（索引优化，索引的方法）	

left join xxx on和where 哪个更快

因为where是在最后数据都查出来的时候去进行的筛选， 而on是在连表的时候进行的过滤，两者操作的数量级别就不一样，而且如果是用where来过滤的话，应该是逐个比较，时间复杂度应该是O(n^2)， 用on的话，实际上是两个B+树索引在进行合并，或许可以利用B+树性质直接降低复杂度至O(logn)。

## redis

```shell
# 过期删除策略（3种）
- 定时删除
  当我们设置一个key到redis时，用一个定时器来负责监视key，当这个key过期就自动删除。虽然内存及时释放，但是十分消耗CPU资源
- 定期删除
  redis默认每隔100ms就会随机抽取一些设置了过期时间的key,检查其是否过期，过期就删除。
- 惰性删除
  当我们获取某个key的时候，再临时检查该key是否过期，过期则删除。惰性删除的缺点也很明显，就是如果一些key使用频率低，那么它可能   长时间存在内存中，占用大量内存

redis使用的过期删除策略是：惰性删除+定期删除。使用这两种结合能很大程度上提高优化redis性能，降低冗余。但还是会有问题，假如定期删除刚好没有删除掉某些过期key,而且这些key又没有使用，这时候就不会触发惰性删除，这些key将长时间存在内存中，占用大量内存，这时候就需要使用内存淘汰机制处理掉这些key.

# 内存数据淘汰机制（6种淘汰策略）
noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

# 缓存击穿
如果缓存中的某些热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。（我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。）

解决方法：
- 互斥锁方案：保证同一时间只有一个线程更新缓存，未能获取互斥锁的请求要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
- 热点数据不设置过期时间

# 缓存穿透

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，应该去后端系统查询（比如数据库）。如果key对应的value不存在，并且对key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

解决方法：
- 非法请求校验：在接口层增加判断请求参数书是否合理，不合理直接返回错误，避免进一步访问缓存和数据库。
- 缓存空值或默认值：查询不到的数据也存入redis，存为空或者默认值，设置较短的过期时间。
- 使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回。
布隆过滤器：https://baijiahao.baidu.com/s?id=1711662604558494579


# 缓存雪崩
当redis服务器 重启 或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如数据库）带来很大的压力。缓存雪崩是指在我们设置缓存时设置了相同的过期时间，导致缓存在某一时期同时失效，请求全部转发到DB，DB瞬间压力过大雪崩。

解决方法：
- 缓存过期时间设置随机：给缓存数据设置过期时间时，避免将大量的数据设置成同一个过期时间。可以在设置过期时间时，加上一个随机数，这样就保证数据不会在同一时间过期。
- 加互斥锁：保证同一时间只有一个线程更新缓存，当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

- 构建集群(故障前)：通过主从节点的方式构建Redis集群。如果主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务。
- 服务熔断(故障时)：可以启动服务熔断机制，暂停对redis服务的访问，直接返回错误，不再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行。等到Redis恢复正常后，再允许访问redis服务。服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服务系统，全部业务都无法正常工作。
- 请求限流(故障时)：为了减少对业务的影响，我们可以启用请求限流机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

# 持久化
把内存中的数据写入到磁盘中去，防止服务宕机导致内存数据丢失。
-RDB（redis database）
Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。
-触发机制
手动触发（save）：阻塞主进程，待持久化操作完成后，恢复正常运行。（bgsave）：创建子进程（fork），后台执行持久化操作。
自动触发：redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；
         主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；
         执行debug reload命令重新加载redis时也会触发bgsave操作；
         默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；

-AOF（append Only File）
每有新增修改操作的时候就会将命令写入到缓存区中，按照配置的规则进行刷新缓存区到磁盘。当aof文件过大时会进行文件重写
-触发机制
everysec：每秒刷一次
always：每有更新操作就刷一次
no：由操作系统自己决定什么时候刷新


# redis部署方式
单机版
主从复制：主 负责写入，从 负责读取
哨兵模式：哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。
集群：采用集群，就是分布式存储。每台redis存储不同的内容



# 缓存更新策略（https://blog.csdn.net/fly910905/article/details/122553972）
- 先删缓存，再更新数据库（不推荐）
- 旁路缓存(Cache Aside) 先更新数据库，再删缓存（常用）
- 先更新数据库，再更新缓存
- 读/写直通(Read/Write Through)：缓存未命中时由缓存加载数据库数据然后应用从缓存读，写数据时更新完缓存后同步写数据库。
- 写回(Write Back)：在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库

# 五种数据类型底层实现
```





Redis为什么这么快？Redis单线程，所有操作在内存中完成，采用的数据结构足够简单

为什么不用Redis做数据存储，而选择用Mysql

## mq

消息中间件的通信方式有几种（点对点和发布订阅）

## es

```shell
# 倒排索引和正向索引
查看笔记 es.md 文件
```



## 线程

如何实现多线程

线程池的线程具体在什么时候创建一个线程或者销毁一个线程

有ABC三个线程，怎么编程让B在C前面执行，A在B前面执行

线程池：https://www.bilibili.com/video/BV1YN411o7Lz

synchronized：加锁

ThreadLocal：为变量生成一个副本

## 设计模式

单例模式（饿汉 懒汉）懒汉线程安全

工厂模式



## 数据结构

链表，数(b,b+,二叉树，红黑树，AVL树)

你了解哪些二叉树的种类和他们的具体使用场景

B+树相比于哈希索引有什么优点？

hashmap的底层实现？



## 算法

```shell
# 时间复杂度 和 空间复杂度

# 回溯算法
17电话号码的字母组合

# 动态规划


# 贪心算法

# 链表

# 双指针
两个端点

# 滑动窗口
区间

# tree

# dfs，bfs
leetcode（104二叉树最大深度、111二叉树最小深度、112路经总和、257二叉树的所有路径、144二叉树的前序遍历、145二叉树的后序遍历）（200岛屿数量、102二叉树的层序遍历、107二叉树的层序遍历Ⅱ）

# 二分法
声明左右指针，while(l<r){int mid = l+(r-l)/2;判断大于mid、等于mid、小于mid 的情况}
34.在排序数组中查找元素的第一个和最后一个位置

# 并查集
leetcode（200岛屿数量、684冗余连接）

# 位运算
leetcode（136只出现一次的数字 结论：0^any = any  a^a=0 a^b^b^c^c=a^c^b^b^c=a）
```





## 框架

### spring

```shell
# AOP
Spring AOP的面向切面编程,是面向对象编程的一种补充,用于处理系统中分布的各个模块的横切关注点,比如事务管理、日志、缓存等.它是使用动态代理实现的,在内存中临时为增强某个方法生成一个AOP对象,这个对象包含目标对象的所有方法,在特定的切入点做了增强处理,并回调原来的方法.

# aop实现方式
Spring AOP的动态代理主要有两种方式实现,JDK动态代理和cglib动态代理.JDK动态代理通过反射来接受被代理的类,但是被代理的类必须实现接口,核心是InvacationHandler和Proxy类.cglib动态代理的类一般是没有实现接口的类,cglib是一个代码生成的类库,可以在运行时动态生成某个类的子类.所以,cglib是通过继承的方式做的动态代理,因此如果某个类被标记为final,那么它是无法使用cglib做动态代理的.

# AOP实际使用过程
https://www.jianshu.com/p/a82509c4bb0d

# Spring bean的生命周期
https://wenku.baidu.com/view/af7cc413edfdc8d376eeaeaad1f34693daef102e.html
1.Spring启动，查找并加载需要被Spring管理的bean，进⾏Bean的实例化。实例化Bean对象是通过反射的⽅式来⽣成，在源码
AbstractAutowireCapableBeanFactory类中中有⼀个createBeanInstance()⽅法是专门来⽣成对象的
2.Bean实例化后将Bean的值注⼊到Bean的属性中。当bean对象创建完成之后，对象的属性值都是默认值，所以要开始给bean填充属性，
通过AbstractAutowireCapableBeanFactory类中的populateBean()⽅法来完成对象属性的填充，中间会涉及到循环依赖的问
题，Spring通过三级缓存解决了这个问题。
3.如果Bean实现了BeanNameAware接⼝的话，Spring将Bean的Id传递给setBeanName()⽅法
4.如果Bean实现了BeanFactoryAware接⼝的话，Spring将调⽤setBeanFactory()⽅法，将BeanFactory容器实例传⼊
5.如果Bean实现了ApplicationContextAware接⼝的话，Spring将调⽤Bean的setApplicationContext()⽅法，将bean所在应⽤上下⽂
引⽤传⼊进来。
6.如果Bean实现了BeanPostProcessor接⼝，Spring就将调⽤他们的postProcessBeforeInitialization()⽅法。
7.如果Bean 实现了InitializingBean接⼝，Spring将调⽤他们的afterPropertiesSet()⽅法。类似的，如果bean使⽤init-method声明了初
始化⽅法，该⽅法也会被调⽤
8.如果Bean 实现了BeanPostProcessor接⼝，Spring就将调⽤他们的postProcessAfterInitialization()⽅法。
9.此时，Bean已经准备就绪，可以被应⽤程序使⽤了。他们将⼀直驻留在应⽤上下⽂中，直到应⽤上下⽂被销毁。
10.如果bean实现了DisposableBean接⼝，Spring将调⽤它的destory()接⼝⽅法，同样，如果bean使⽤了destory-method 声明销毁⽅
法，该⽅法也会被调⽤。

# bean生命周期：bean定义，构造方法推断，实例化，属性填充（程序员可自定义），初始化，初始化后

```

### mybatis

````shell
# Mybatis 的 ${} #{}的区别是什么？

````

### spring mvc

```shell
Spring MVC中，@RequestMapping的实现原理？
```



## 集合

```shell
# hashMap相关面试题
https://www.bilibili.com/video/BV16Z4y1U7HN

# 如果hashmap溢出了怎么办
https://www.jianshu.com/p/59ccb6bcc740

# ArrayList
无参构造函数默认初始化长度为 10 ,数组扩容是会将原数组中的元素重新拷贝到新数组中,长度为原来的1.5+1(代扩容价高)



```



## 其它

http1.0和http2.0的区别

http和https的区别

三次握手、四次挥手

hashmap和1.8的concurrent hashmap

项目的限流怎么实现的

ConcurrentHashMap为什么是线程安全的？

Mysql、Redis、MQ 之间的区别和适用场景？

两个文件，各有两个行，一个是身份证号、名字，一个是身份证号、年龄。内存不足的情况下，如果进行合并？

 一维数组跟二维数组有什么区别？

有一个hashset 你有什么方式遍历它呢

迭代器跟foreach有什么区别呢？

互斥锁，自旋锁，读写锁，悲/乐观锁：https://baijiahao.baidu.com/s?id=1678252166115910894







