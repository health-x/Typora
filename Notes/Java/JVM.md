# JVM

![image-20211227171337935](../../assets/image-20211227171337935.png)

.java文件 经过 javac编译器 编译为 .class文件，.class文件 经过类加载器(ClassLoader) 后才能被加载到jvm中去运行

在JVM中 ：.class文件 经过解释器处理为 机器码 ，CPU拿到机器码进行处理



## JVM内存结构

方法区、堆、虚拟机栈、程序计数器、本地方法栈



## 1. 程序计数器

作用：记住下一条 jvm 指令的执行地址

特点：

- 线程私有的，每个线程执行字节码文件时是相互独立的。
- 不会存在内存溢出

工作流程：程序计数器拿到二进制字节码文件后，将其中的 jvm 指令逐行交给解释器（同时保存下一条指令的执行地址），解释器把指令解释为机器码，然后交给cpu处理。



## 2. 虚拟机栈

**虚拟机栈：**每个线程运行时所需要的内存空间，被称为虚拟机栈。

**特点：**

- <font color="red">先进后出</font>
- 多个线程运行则需要多个虚拟机栈，线程私有，相互独立。
- 每个线程只能有一个活动栈帧。活动栈帧即线程正在执行的那个方法对应的栈帧。

**栈帧：**每个栈中包含多个栈帧，每个方法运行时需要的内存被称为栈帧（栈帧中包括：参数、局部变量、返回地址等）。

**流程：**调用某个方法时会为该方法分配栈帧空间，然后将该栈帧压入栈内，当该方法执行完成后，会将该栈帧出栈，释放空间。如果在方法执行的中途调用其它方法，则同样为将这个方法分配栈帧空间，入栈，执行，出栈。然后再继续执行前一个方法。

**栈内存分配参数**：在VM options选项中配置，-Xss256k		//1兆就写1m

**栈内存溢出：**StackOverFlowError

- 一个栈中不断地加入栈帧，而没有出栈，当超出该栈的容量时，会产生栈内存溢出（一般会在递归调用没有设置正确的结束值的时候出现此情况）
- 栈帧过大，超过了栈内存的容量大小，也会出现占内存溢出的情况（很少发生）



## 3. 本地方法栈（native）

c或者c++写的调用底层东西的方法

作用跟虚拟机栈类似，就是处理的对象不同



## 4. 堆（Heap）

通过new关键字，创建的对象都会使用堆内存。

**特点：**

- 线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

**堆内存分配参数**：在VM options选项中配置，-Xmx8m		//1G就写1g

**堆内存溢出：** java.lang.OutOfMemoryError：Java heap space



## 5. 方法区

存放类
