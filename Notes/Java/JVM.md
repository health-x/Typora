# JVM

![image-20211227171337935](../../assets/image-20211227171337935.png)

.java文件 经过 javac编译器 编译为 .class文件，.class文件 经过类加载器(ClassLoader) 后才能被加载到jvm中去运行

在JVM中 ：.class文件 经过解释器处理为 机器码 ，CPU拿到机器码进行处理



## JVM内存结构

方法区、堆、虚拟机栈、程序计数器、本地方法栈



## 1. 程序计数器

作用：记住下一条 jvm 指令的执行地址

特点：

- 线程私有的，每个线程执行字节码文件时是相互独立的。
- 不会存在内存溢出

工作流程：程序计数器拿到二进制字节码文件后，将其中的 jvm 指令逐行交给解释器（同时保存下一条指令的执行地址），解释器把指令解释为机器码，然后交给cpu处理。



## 2. 虚拟机栈

**虚拟机栈：**每个线程运行时所需要的内存空间，被称为虚拟机栈。

**特点：**

- <font color="red">先进后出</font>
- 多个线程运行则需要多个虚拟机栈，线程私有，相互独立。
- 每个线程只能有一个活动栈帧。活动栈帧即线程正在执行的那个方法对应的栈帧。

**栈帧：**每个栈中包含多个栈帧，每个方法运行时需要的内存被称为栈帧（栈帧中包括：参数、局部变量、返回地址等）。

**流程：**调用某个方法时会为该方法分配栈帧空间，然后将该栈帧压入栈内，当该方法执行完成后，会将该栈帧出栈，释放空间。如果在方法执行的中途调用其它方法，则同样为将这个方法分配栈帧空间，入栈，执行，出栈。然后再继续执行前一个方法。

**栈内存分配参数**：在VM options选项中配置，-Xss256k		//1兆就写1m

**栈内存溢出：**StackOverFlowError

- 一个栈中不断地加入栈帧，而没有出栈，当超出该栈的容量时，会产生栈内存溢出（一般会在递归调用没有设置正确的结束值的时候出现此情况）
- 栈帧过大，超过了栈内存的容量大小，也会出现占内存溢出的情况（很少发生）



## 3. 本地方法栈（native）

c或者c++写的调用底层东西的方法

作用跟虚拟机栈类似，就是处理的对象不同



## 4. 堆（Heap）

通过new关键字，创建的对象都会使用堆内存。

**特点：**

- 线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

**堆内存分配参数**：在VM options选项中配置，-Xmx8m		//1G就写1g

**堆内存溢出：** java.lang.OutOfMemoryError：Java heap space



## 5. 方法区

方法区在虚拟机启动时被创建，逻辑上是堆的组成部分。

存储运行时常量池、属性、方法、方法和构造器

**方法区内存分配参数**：在VM options选项中配置

- -XX:MaxMetaspaceSize=8m	//元空间
- -XX:MaxPermSize=8m	//永久代

**方法区内存溢出：** java.lang.OutOfMemoryError：Metaspace(元空间) / PermGen space(永久代)

**特点：**线程共享



jdk1.6里，方法区的实现叫做**永久代**，存储类，类加载器，运行时常量池（包含串池）信息，由jvm管理

jdk1.8以后，永久代的实现被废弃了，改用了**元空间**作为方法区的实现。存储类，类加载器，运行时常量池信息。此时的方法区的实现已经被移到了本地内存（系统内存）中进行管理了，基本不会发生内存溢出的问题了。串池也被移到了堆中，

<img src="../../assets/image-20220120160205654.png" alt="image-20220120160205654"  />



**二进制字节码文件**：包含 类的基本信息，常量池，类方法定义，包含了虚拟机指令

**反编译指令**：java -v xxx.class		-v：显示详细信息

**常量池：**就是一张常量表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。

**运行时常量池：**常量池是 *.class文件中的，当该类被加载，他的常量池信息就会被放入运行时常量池（存储在内存中），并把里面的符号地址变为真实地址。



























